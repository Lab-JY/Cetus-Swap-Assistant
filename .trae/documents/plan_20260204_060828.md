# 验证原子化 Zap 功能 (Verification Plan)

您说得对，代码改动后必须进行验证。由于我们处于无头环境（Headless），无法直接进行点击测试，我将编写一个 **集成测试脚本** 来模拟核心逻辑的执行。

## 测试目标
验证 Phase 3 的两个核心改动是否有效：
1.  **合成路由 (Synthetic Router)**: 验证能否成功将 CLMM 直连数据伪装成 Aggregator 路由。
2.  **统一执行 (Unified Execution)**: 验证 `buildSimpleSwapTx` 能否接受这个“伪装”的报价，并成功调用 `aggregator.routerSwap` 构建出交易（不报错即成功）。

## 测试脚本设计
我将创建脚本 `scripts/verify_atomic_zap.ts`，包含以下步骤：

### 1. 模拟合成报价 (Mock Synthetic Quote)
手动构造一个符合 `RouterDataV3` 接口的“合成报价对象”。这将完全模拟 `getSwapQuote` 在降级时的输出格式：
- `source`: `'aggregator'` (伪装身份)
- `isSynthetic`: `true` (标记)
- `router`: 包含单跳 (Single Hop) 的路径数据，指向测试网的一个真实池子 (SUI-MEME)。

### 2. 执行交易构建 (Test Transaction Build)
- 初始化一个空的 `Transaction` 对象。
- 调用 `buildSimpleSwapTx`，传入上述合成报价。
- **预期结果**:
    - 函数**不应抛出错误**。
    - 如果 `aggregator.routerSwap` 成功运行，说明我们的“欺骗”策略生效了，SDK 认可了这份数据。
    - 最终生成的 `finalTx` 应该包含 Swap 相关的命令。

## 执行计划
1.  创建 `scripts/verify_atomic_zap.ts`。
2.  使用 `npx tsx` 运行该脚本。
3.  根据输出日志确认测试通过。