# Phase 3: 原子化 CLMM Zap 实现方案

我的方案是采用 **"统一路由执行策略" (Unified Router Execution)**。

目前系统中有两套交易构建逻辑：
1. **Aggregator 模式**：使用 `aggregator.routerSwap`，支持原子化 Zap（Swap + Transfer 在同一笔交易）。
2. **CLMM 直连模式**：使用 `cetusClmm.Swap.createSwapTransactionPayload`，不支持原子化，被迫使用 "两步走"（先 Swap 回钱包，再用户签名转账）。

## 核心思路
**不重写底层 CLMM 交易逻辑，而是将 CLMM 的报价伪装成 Aggregator 的单跳路由。**

Cetus 的 Aggregator SDK 本质上是一个兼容层，它完全有能力执行 "单跳直连" 的交易。只要我们将 CLMM 的报价数据格式化为 `RouterDataV3` 结构，就可以直接复用 `aggregator.routerSwap` 方法。

这样一来，**所有的 Swap（无论是聚合路由还是直连池子）都将通过 Aggregator SDK 执行**，从而自然获得原子化 Zap 的能力。

## 具体执行步骤

### 1. 改造 `getSwapQuote` (数据层)
在 `tx-builder.ts` 中，当系统决定降级使用 CLMM 直连报价时，不再直接返回原始的 CLMM 结果，而是构造一个 **合成路由对象 (Synthetic Router Object)**。

该对象将包含：
- `amountIn` / `amountOut`: 来自 CLMM 预计算结果。
- `paths`: 一个只包含单跳（Single Hop）的路径数组，填入直连池子的信息（Pool Address, CoinType A/B, Provider='CETUS'）。

### 2. 统一 `buildSimpleSwapTx` (执行层)
- **移除**旧的 `cetusClmm.Swap.createSwapTransactionPayload` 分支逻辑。
- **统一**所有逻辑入口：无论来源是 `aggregator` 还是 `clmm`，都统一调用 `aggregator.routerSwap`。
- 这样，`targetCoin`（Swap 后的代币对象）就能被直接获取，并立即传入后续的 `buildTransferTx` 中。

### 3. 清理前端逻辑
- 修改 `page.tsx`，移除 "Step 2" 相关的状态和提示逻辑。
- 用户现在只需点击一次 "Confirm Swap/Zap"，即可完成全部操作。

## 预期效果
- **用户体验**：Zap 操作（换币+转账）从 **2 次签名** 变为 **1 次签名**。
- **安全性**：消除了中间状态，代币不会因为用户拒绝第二次签名而滞留在中转钱包中。
- **代码质量**：大幅简化 `tx-builder.ts`，消除了分支维护成本。